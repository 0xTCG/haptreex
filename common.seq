from math import erf, sqrt, factorial


CUTOFF = 0
QUALITY_CUTOFF = 10
CONFIDENCE = 0.5
PAIR_TRESH = 0.8

DOT = -10 # "."
V = dict[int, dict[int, int]]()


class Pair[T]:
    x: T
    y: T
    def __getitem__(self: Pair[T], i: int):
        return self.x if i == 0 else self.y
    def __hash__(self: Pair[T]):
        return (self.x, self.y).__hash__()
    def __eq__(self: Pair[T], other: Pair[T]):
        return (self.x, self.y) == (other.x, other.y)
    def __ne__(self: Pair[T], other: Pair[T]):
        return (self.x, self.y) == (other.x, other.y)
    def __len__(self: Pair[T]):
        return 2
    def __str__(self: Pair[T]):
        return (self.x, self.y).__str__()
    #def __getitem__(self: Pair[T], i: int):
    #    return self.x if i == 0 else self.y

def cdf(n: int, k: int, var: int) -> float:
    p = 0.5
    mu = n * p if var == 0 else n * (1 - p)
    return 0.5 * (1 + erf((k + 0.5 - mu) / sqrt(2 * n * p * (1 - p))))


# def binom(n: int, k: int) -> int:
#     # n CHOOSE k
#     j = min(k, n - k)
#     numerator = 1
#     for i in range(j):
#         numerator = numerator * (n - i)
#     return numerator // factorial(j)
def binom(N: int, k: int) -> int:
    """https://github.com/scipy/scipy/blob/v1.3.3/scipy/special/_comb.pyx"""
    # Fast path with machine integers
    INT_MAX = int((u64(1) << u64(63)) - u64(1))
    if k > N or N == INT_MAX:
        return 0
    M = N + 1
    nterms = min(k, N - k)
    val = 1
    for j in range(1, nterms + 1):
        if val > INT_MAX // (M - j):
            return 0
        val *= M - j
        val //= j
    return int(val)


def score(pair: list[int]) -> float:
    """
    Computing probability that a fair coin generates something as or more
    extremely biased than we we are seeing.
    """
    
    k = min(pair)
    var = 0 if pair[0] == k else 1
    p = 0.5
    n = sum(pair)
    if n > 50:
        return cdf(n, k, var)
    else:
        prob = 0.0
        for i in range(k + 1):
            if var == 0:
                prob += (p ** i) * ((1 - p) ** (n - i)) * binom(n, i)
            else:
                prob += ((1 - p) ** i) * (p ** (n - i)) * binom(n, i)
        return prob
