from math import log
from read import Read
from common import CONFIDENCE
import sys


def read_val_tail(
    partial_phase: tuple[dict[int, int], dict[int, int]],
    p: float,
    error: float,
    relevant_reads: list[Read],
    m: int,
    m_prev: int
) -> float:
    """
    we extend a phasing and then calculating how likely that extension is
    this looks at the prob of a particular phasing generating the set of reads 
    which cover "end" ( = "m") and for which "end" is not the smallest SNP in the read. 
    (relevant reads for the extension)
    this log prob gets added to the log prob of the non-extended phasing.
    """

    a = (1 - error) / (1 - (2 * error / 3.0))
    b = (error / 3.0) / (1 - (2 * error / 3.0))
    val, val2 = 0.0, 0.0 
    for read_obj in relevant_reads:
        probs, probs2 = 0.0, 0.0
        for i, pp in enumerate(partial_phase):
            prob = (CONFIDENCE * read_obj.rates[i]) + (0.5 * (1 - CONFIDENCE))
            mini_read = read_obj.mini_reads[m]
            for key in mini_read:
                prob *= (a if mini_read[key] == pp[key] else b)
            probs2 += prob / (a if mini_read[m] == pp[m] else b)
            probs += prob
        if probs == 0:
            val = -float("inf")
        else:
            val += log(probs) * read_obj.count
            if not m == read_obj.special_key:
                val2 += log(probs2) * read_obj.count

    # p is some measure of likelihood of adjacent mutations occuring together
    # since we've know extended the haplotype we need to update the prior
    if len(partial_phase[0]) > 1:
        val += log(p if partial_phase[0][m] == partial_phase[0][m_prev] else 1 - p)
    return val - val2


# def branch(m: int,m_prev: Optional[int],LISTS: Union[list[dict[int, dict[int, int]]], list[dict[int, DUMMY_NAME]]],DICT: dict[int, Union[int, float]],threshold: float,p: float,error: float,read_dict: dict[int, list[Read]]) -> tuple[list[dict[int, dict[int, int]]], dict[int, float]]:
def branch(
    m: int,
    m_prev: int,
    lists: list[tuple[dict[int, int], dict[int, int]]],
    table: dict[int, float],
    threshold: float,
    p: float,
    error: float,
    read_dict: dict[int, list[Read]]
):
    """
    k=2 only
    branch all solutions to highly probable solutions on one additional SNP
    lists include all current solutions
    dict has list index of solutions and their likelihoods
    """
    
    threshold = log(threshold / (1 - threshold))
    new_lists = list[tuple[dict[int, int], dict[int, int]]]()
    new_table = dict[int, float]()
    for i, partial_phase in enumerate(lists):
        # extend solution
        costs = dict[tuple[int, int], float]()
        for c in ((0, 1), (1, 0)):
            # adding possible orderings of alleles for new SNP for diploid
            partial_phase[0][m], partial_phase[1][m] = c
            costs[c] = read_val_tail(partial_phase, p, error, read_dict[m], m, m_prev)
        max_cost = max(costs.values())
        new_costs = {key: costs[key] - max_cost for key in costs}
        for c in costs:
            if new_costs[c] >= threshold:
                # adds extension with allele ordering c if sufficiently likely
                extended_phase = (copy(partial_phase[0]), copy(partial_phase[1])) if c[0] == 1 else partial_phase
                extended_phase[0][m], extended_phase[1][m] = c
                # adds new solution to the dict with its new likelihood
                # all the entries are positive instead of negative
                new_table[len(new_lists)] = table[i] - costs[c]
                new_lists.append(extended_phase)
    return new_lists, new_table


def prune(
    m: int,
    lists: list[tuple[dict[int, int], dict[int, int]]],
    table: dict[int, float],
    components: dict[int, list[int]]
):
    # prune solutions based on number of solutions and thresholds
    n = max(components[m])
    L = len(lists)
    count_list_index = 0
    new_lists = list[tuple[dict[int, int], dict[int, int]]]()
    new_dict = dict[int, float]()
    go = False
    threshold = 1.0
    if m == n:
        threshold = 1.0
        go = True
    elif L > 1000:
        threshold = 0.1
    elif L > 500:
        threshold = 0.05
    elif L > 100:
        threshold = 0.01
    else:
        threshold = 0.001

    threshold = abs(log(threshold))
    min_val = min(table.values())
    for i in range(len(lists)):
        l = lists[i]
        if abs(table[i] - min_val) < threshold + 0.0001:
            new_lists.append(l)
            new_dict[count_list_index] = table[i]
            count_list_index += 1
    if go:
        new_index = 0  # random.randint(0, len(new_lists)-1)
        new_lists = [new_lists[new_index]]
        new_dict = {0: new_dict[new_index]}
    return new_lists, new_dict    


def RNA_phase(
    threshold: float,
    p: float,
    error: float,
    read_dict: dict[int, list[Read]],
    comp_mins: list[int],
    components: dict[int, list[int]]
):
    phases = dict[int, tuple[dict[int, int],  dict[int, int]]]()
    for start in comp_mins:
        # find phasing solution for connected component starting at start
        lists = [(dict[int, int](), dict[int, int]())]
        table = {0: 0.0}
        skipped = True  # set to True to allow allele permutations
        m_prev = -1 # SEQ/TODO: check! originally  None
        for m in components[start]:
            if skipped:
                lists, table = branch(m, m_prev, lists, table, threshold, p, error, read_dict)
                # print(f'!lists: {start} {m} .. {m_prev} -> {lists}')
                lists, table = prune(m, lists, table, components)
                # print(f'@lists: {start} {m} .. {m_prev} -> {lists}')
            else:  # specify beginning to remove allele permutations
                lists = [(dict[int, int](), dict[int, int]())]
                table = {0: 0.0}
                skipped = True
            m_prev = m
        # print(f'{start} -> {components[start]} {lists[0]}')
        phases[start] = lists[0]
    return phases
