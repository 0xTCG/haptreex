from os.path import splitext
from core.file import is_binary
from bio.bam import *

from read import SNP, Read
from graph import Graph
from rna import Gene, RNAGraph


QUALITY_CUTOFF = 10
CHECK_HETEROZYGOUS = True


class VCF:
    snps: list[SNP]
    line_to_snp: dict[int, int]  # 1-based index
    chromosomes: dict[str, tuple[int, int]]  # Chromosome name to the SNP span

    def find_first(self, chr: str, pos: int) -> int:
        if chr not in self.chromosomes:
            return -1
        lo, hi = self.chromosomes[chr]
        while lo < hi:
            mid = (lo + hi) // 2
            if self.snps[mid].pos < pos:
                lo = mid + 1
            else:
                hi = mid
        return lo


def parse_vcf(vcf_path: str, sample_name: optional[str] = None) -> VCF:
    """
    Parse a VCF file and return a dictionary of sorted SNPs:
        d := {chromosome_name: sorted([snp_1, snp_2])}
    and the corresponding line index
        {line_in_vcf: (chr, index in d[chr])}.
    Each snp_i is a SNP that is heterozygous in the sample (i.e. |set(GT(snp_i))| > 1).
    """

    snps = list[SNP]()
    line_to_snp = dict[int, int]()
    chromosomes = dict[str, tuple[int, int]]()
    with open(vcf_path) as vcf:
        # samples = list(vcf.header.samples)
        # if not samples:
        #     raise ValueError('No samples present in the VCF file')
        # if sample_name and sample_name not in samples:
        #     raise ValueError(f'Sample {sample_name} not found in the VCF')
        # sample_name = sample_name if sample_name else samples[0]
        # print(f'Using sample {sample_name} in {vcf_path}...')
        prev_chr, seen_snps = "", 0
        for line in vcf:
            if line[0] == '#':
                continue
            seen_snps += 1
            chr, pos, id, ref, alt, _, _, _, fmt_, sample = line.split('\t')
            if len(ref) != 1:  # Ignore indels
                continue
            # We only deal with SNPs here for now
            fmt = dict(zip(fmt_.split(':'), sample.split(':')))
            gt = fmt['GT'].replace('|', '/').split('/')
            potential_alleles = [ref] + alt.split(',')
            # Get only alleles that are specified in GT field
            alleles = [
                seq(a) 
                for i, a in enumerate(potential_alleles) 
                if str(i) in gt and len(a) == 1
            ]
            if len(alleles) > 1:  # Ignore homozygous SNPs
                snp = SNP(len(snps), chr, int(pos) - 1, id, alleles)
                if snps and snp < snps[-1]:  # TODO
                    raise ValueError(f'VCF is not sorted (SNP {snp})')
                line_to_snp[seen_snps] = len(snps)
                if chr not in chromosomes:
                    if prev_chr:
                        chromosomes[prev_chr] = (chromosomes[prev_chr][0], len(snps))
                    chromosomes[chr] = (len(snps), -1)
                    prev_chr = chr
                snps.append(snp)
        if prev_chr:
            chromosomes[prev_chr] = (chromosomes[prev_chr][0], len(snps))
    return VCF(snps, line_to_snp, chromosomes)


def parse_gtf(gtf_path: str, chroms: dict[str, tuple[int, int]]) -> Gene:
    b = [a.split("\t") for a in open(gtf_path, "r") if a[0] != '#']

    def parse_f(f):
        x, y = f.split(" ", 1)
        return x, y[1:-1] if y[0] == y[-1] == '"' else y

    gi, i = 0, 0
    while i < len(b):
        if b[i][2] == "transcript":
            chr, interval, sign = b[i][0], (int(b[i][3]) - 1, int(b[i][4])), b[i][6]
            if chr not in chroms:
                continue
            info = dict(parse_f(f.strip()) for f in b[i][8].split(";") if f.strip())
            name = info.get("gene_name", info["transcript_id"])
            i += 1
            exons = list[tuple[int, int]]()
            while i < len(b) and b[i][2] != "transcript":
                if b[i][2] == "exon":
                    exon_start, exon_end = int(b[i][3]) - 1, int(b[i][4])
                    exons.append((exon_start, exon_end))
                i += 1
            yield Gene(gi, name, chr, interval, sign, exons)
            gi += 1
        else:
            i += 1


def parse_read(
    vcf: VCF,
    handle: BAM,
    lines: list[SAMRecord],
    threshold: int,
    ignore_conflicts: bool = True
) -> tuple[str, list[tuple[int, int, str]]]:
    """
    If reads are valid and pass the threshold filter, yields the
        (read_name, [all_1, all_2, ...])
    where
        all_i := (snp, allele, quality).
    Example:
        ('read1', [(SNP("chr1", 12), 'A', 'E'), ...])
    """

    cov = dict[int, dict[int, list[str]]]()  # SNP: {allele: [qual1, qual2, ...]}
    name = lines[0].query_name
    counts = [0] * len(lines)
    for line_i, sam in enumerate(lines):
        chr = handle.reference_name(sam.tid)
        read, ref = 0, 0
        for sz, op in sam.cigar:
            match op:
                case 'M' or '=' or 'X':
                    start = vcf.find_first(chr, sam.pos + ref)
                    for i in range(start, vcf.chromosomes[chr][1]):
                        snp = vcf.snps[i]
                        if snp.pos >= sam.pos + ref + sz:
                            break
                        t = snp.pos - sam.pos - ref + read
                        if sam.read[t] in snp.alleles:
                            allele = snp.alleles.index(sam.read[t])
                            qual = sam.qual[t] if sam.qual != '*' else '.'
                            aq = cov.setdefault(i, dict[int, list[str]]())
                            aq.setdefault(allele, list[str]()).append(qual)
                            counts[line_i] += 1
                    read += sz
                    ref += sz
                case 'I' or 'S':
                    read += sz
                case 'D' or 'N' or 'H' or 'P':
                    ref += sz
                case _:
                    pass
    # Adding an MP suffix like extractHairs to specify that matepairs are merged
    # if len(counts) > 1 and counts[0] > 0 and counts[1] > 0: name += "_MP"
    # Filter out SNPs that harbour mate-pair allele conflicts
    if ignore_conflicts:
        for i in list(cov):
            if len(cov[i]) > 1:
                del cov[i]
    if len(cov) >= threshold:
        yield name, [
            (sid, a, max(q))
            for sid, A in cov.items()
            for a, q in A.items()
        ]


def parse_bam(
    vcf: VCF,
    sam_path: str,
    threshold: int = 1,
    no_duplicates: bool = True,
    no_conflicts: bool = True
) -> tuple[str, list[tuple[int, int, str]]]:
    """
    Reads a SAM/BAM. Does not have to be sorted.
    """

    seen = dict[str, SAMRecord]()
    seen_chrs = set[str]()
    with BAM(sam_path) as sam:
        parse = parse_read(vcf, sam, ..., threshold, no_conflicts)
        for line_i, line in enumerate(sam):
            chr = sam.reference_name(line.tid)
            if chr not in seen_chrs or line_i % 10000000 == 0:
                print (
                    f'Parsing {chr}; '
                    + f'{len(seen)} cached so far; '
                    + f'{line_i} processed so far...'
                )
            seen_chrs.add(chr)
            name = line.query_name
            if len(name) > 2 and name[-2] in '#/':
                name = name[:-2]
            if (
                line.supplementary
                or (no_duplicates and line.duplicate)
                or chr != sam.reference_name(line.mate_tid)
                or line.unmapped
                or not len(line.cigar)
                or chr not in vcf.chromosomes
            ):
                if not line.supplementary and not line.mate_unmapped and name in seen:
                    yield from parse([seen[name]])
                    del seen[name]
                continue
            elif name in seen:
                yield from parse([seen[name], line])
                del seen[name]
            else:
                seen[name] = line
        for line in seen.values():
            yield from parse([line])


def parse_fragmat(
    vcf: VCF, fragmat: str
) -> tuple[str, list[tuple[int, int, str]]]:
    """
    Yields reads in the format
        (read_name, [(snp_id, allele_id, qual), ...])
    """
    print(f"Loading and formatting fragments...")
    if is_binary(fragmat):
        raise ValueError(f'{fragmat} is not valid fragmat file')
    with open(fragmat) as f:
        for r in f:
            frag = r.split()
            if not frag[0].isdigit(): 
                ValueError(f'{fragmat} is not valid fragmat file')
            name, qual, frag = frag[1], frag[-1], frag[2:-1]
            if len(frag) % 2 == 1:
                raise ValueError(f"fragment file error: {frag}")
            if len(qual) == 1 and ord(qual) < QUALITY_CUTOFF:  # TODO: fix this
                continue

            alleles = list[tuple[int, int, str]]()
            for i in range(0, len(frag), 2):
                idx = int(frag[i])
                for allele in frag[i + 1]:
                    if idx not in vcf.line_to_snp:
                        print(f'Warning: Invalid SNP index {idx} for read {name}')
                        continue
                    snp = vcf.snps[vcf.line_to_snp[idx]]
                    if not 0 <= int(allele) < len(snp.alleles):
                        raise ValueError(f'Invalid allele {allele} for SNP {snp}')
                    alleles.append((snp.id, int(allele), qual[len(alleles)]))
                    idx += 1
            yield name, alleles


def parse_phases(
    vcf: VCF,
    paths: list[str],
    skip_single: bool = True
) -> Read:
    reads = list[list[tuple[int, int, str]]]()
    for path in paths:
        print(f'Parsing {path}...')
        _, ext = splitext(path)
        it = (
            parse_bam(vcf, path, 1) 
            if ext in ['.sam', '.bam', '.cram'] 
            else parse_fragmat(vcf, path)
        )
        coverages = dict[int, set[int]]()
        path_reads = list[list[tuple[int, int, str]]]()
        for name, alleles in it:
            if not (skip_single and len(alleles) <= 1):
                for pos, al, _ in alleles:
                    coverages.setdefault(pos, set[int]()).add(al)
                path_reads.append(alleles)
        # Ensure that all reads have expressed SNPs
        if CHECK_HETEROZYGOUS:
            for read in path_reads:
                read = [i for i in read if i[0] in coverages and len(coverages[i[0]]) >= 2]
                if len(read) and not (skip_single and len(read) <= 1):
                    reads.append(read)
    print(f"{len(reads)} reads of sufficient quality")

    read_counter = dict[list[tuple[int, int]], int]()
    for r in reads:
        key = sorted((s, a) for s, a, _ in r)
        if len(key) <= int(skip_single):
            continue
        if key not in read_counter:
            read_counter[key] = 1
        else:
            read_counter[key] += 1
    print(f"{len(read_counter)} distinct reads")

    for i, t in enumerate(read_counter.items()):
        yield Read({snp_id: snp_a for snp_id, snp_a in t[0]}, t[1], i)


def load_rna_data(
    vcf: VCF,
    gtf_path: str,
    paths: list[str],
    isoforms_path: str
) -> RNAGraph:
    print(f"Loading GTF {gtf_path}...")
    genes = list(parse_gtf(gtf_path, vcf.chromosomes))
    print(f"{len(genes)} genes in GTF file")

    reads = list(parse_phases(vcf, paths, skip_single=False))
    if isoforms_path:
        print("Building IsoDict...")
        raise NotImplementedError("IsoDict")
        #isodict = build_isodict(isoforms_path)
        #genes = filter_transcripts(genes, isodict)

    return RNAGraph(
        vcf.snps, 
        genes, 
        reads,
        size_factor = 2,
        rate_factor = 0.2,
        rate_cutoff = 0.6,
        coverage_cutoff = 0,
        rate_dep_cutoff = 2,
        cutoff = 0.001,
        conf = 0.2
    )


def load_dna_data(
    vcf: VCF,
    paths: list[str],
    ploidy: int = 2,
    rna_reads: optional[list[Read]] = None
) -> Graph:
    reads = list(parse_phases(vcf, paths, skip_single=True))
    if rna_reads:
        reads += ~rna_reads
    for r in reads:
        r.special_snp = sorted(r.snps)[1]
        r.rates = [0.5] * ploidy

    return Graph(reads, ploidy)
