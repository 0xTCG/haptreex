from os.path import splitext
from core.file import is_binary
from bio.bam import *

from read import SNP, Read
from graph import Graph
from rna import Gene, RNAGraph
import sys


QUALITY_CUTOFF = 10
ONLY_HETEROZYGOUS = False


class VCF:
    snps: list[SNP]
    line_to_snp: dict[int, int]  # 1-based index
    chromosomes: dict[str, tuple[int, int]]  # Chromosome name to the SNP span
    chr_ordered: list[str]

    def find_first(self, chr: str, pos: int) -> int:
        if chr not in self.chromosomes:
            return -1
        lo, hi = self.chromosomes[chr]
        while lo < hi:
            mid = (lo + hi) // 2
            if self.snps[mid].pos < pos:
                lo = mid + 1
            else:
                hi = mid
        return lo


def parse_vcf(vcf_path: str, sample_name: optional[str] = None) -> VCF:
    """
    Parse a VCF file and return a dictionary of sorted SNPs:
        d := {chromosome_name: sorted([snp_1, snp_2])}
    and the corresponding line index
        {line_in_vcf: (chr, index in d[chr])}.
    Each snp_i is a SNP that is heterozygous in the sample (i.e. |set(GT(snp_i))| > 1).
    """

    snps = list[SNP]()
    line_to_snp = dict[int, int]()
    chromosomes, chr_ordered = dict[str, tuple[int, int]](), list[str]()
    with open(vcf_path) as vcf:
        # samples = list(vcf.header.samples)
        # if not samples:
        #     raise ValueError('No samples present in the VCF file')
        # if sample_name and sample_name not in samples:
        #     raise ValueError(f'Sample {sample_name} not found in the VCF')
        # sample_name = sample_name if sample_name else samples[0]
        # print(f'Using sample {sample_name} in {vcf_path}...')
        prev_chr, seen_snps = "", 0
        for line in vcf:
            if line[0] == '#':
                continue
            seen_snps += 1
            chr, pos, id, ref, alt, _, _, _, fmt_, sample = line.split('\t')
            if len(ref) != 1:  # Ignore indels
                continue
            # We only deal with SNPs here for now
            fmt = dict(zip(fmt_.split(':'), sample.split(':')))
            gt = fmt['GT'].replace('|', '/').split('/')
            potential_alleles = [ref] + alt.split(',')
            # Get only alleles that are specified in GT field
            alleles = [
                seq(a)
                for i, a in enumerate(potential_alleles)
                if str(i) in gt and len(a) == 1
            ]
            if len(alleles) > 1:  # Ignore homozygous SNPs
                snp = SNP(len(snps), chr, int(pos) - 1, id, alleles)
                if snps and snp < snps[-1]:  # TODO
                    raise ValueError(f'VCF is not sorted (SNP {snp})')
                line_to_snp[seen_snps] = len(snps)
                if chr not in chromosomes:
                    chr_ordered.append(chr)
                    if prev_chr:
                        chromosomes[prev_chr] = (chromosomes[prev_chr][0], len(snps))
                    chromosomes[chr] = (len(snps), -1)
                    prev_chr = chr
                snps.append(snp)
        if prev_chr:
            chromosomes[prev_chr] = (chromosomes[prev_chr][0], len(snps))
    return VCF(snps, line_to_snp, chromosomes, chr_ordered)


def parse_gtf(gtf_path: str, chroms: dict[str, tuple[int, int]]) -> Gene:
    b = [a.split("\t") for a in open(gtf_path, "r") if a[0] != '#']

    def parse_f(f):
        x, y = f.split(" ", 1)
        return x, y[1:-1] if y[0] == y[-1] == '"' else y

    gi, i = 0, 0
    while i < len(b):
        # sys.stdout.write(f"\r{i} ... {b[i][0]}:{b[i][2]}")
        if b[i][2] == "transcript":
            chr, interval, sign = b[i][0], (int(b[i][3]) - 1, int(b[i][4])), b[i][6]
            if chr not in chroms:
                i += 1
                continue
            info = dict(parse_f(f.strip()) for f in b[i][8].split(";") if f.strip())
            name = info.get("gene_name", info["transcript_id"])
            i += 1
            exons = list[tuple[int, int]]()
            while i < len(b) and b[i][2] != "transcript":
                if b[i][2] == "exon":
                    exon_start, exon_end = int(b[i][3]) - 1, int(b[i][4])
                    exons.append((exon_start, exon_end))
                i += 1
            yield Gene(gi, name, chr, interval, sign, exons)
            gi += 1
        else:
            i += 1


def parse_read(
    vcf: VCF,
    handle: BAM,
    lines: list[SAMRecord],
    threshold: int,
    ignore_conflicts: bool,
    is_tenx: bool
) -> tuple[tuple[str, int], list[tuple[int, int, str]]]:
    """
    If reads are valid and pass the threshold filter, yields the
        (read_name, [all_1, all_2, ...])
    where
        all_i := (snp, allele, quality).
    Example:
        ('read1', [(SNP("chr1", 12), 'A', 'E'), ...])
    """

    cov = dict[int, dict[int, list[str]]]()  # SNP: {allele: [qual1, qual2, ...]}
    name = lines[0].query_name
    counts = [0] * len(lines)
    for line_i, sam in enumerate(lines):
        chr = handle.reference_name(sam.tid)
        read, ref = 0, 0
        for sz, op in sam.cigar:
            match op:
                case 'M' or '=' or 'X':
                    start = vcf.find_first(chr, sam.pos + ref)
                    for i in range(start, vcf.chromosomes[chr][1]):
                        snp = vcf.snps[i]
                        if snp.pos >= sam.pos + ref + sz:
                            break
                        t = snp.pos - sam.pos - ref + read
                        if sam.read[t] in snp.alleles:
                            allele = snp.alleles.index(sam.read[t])
                            qual = sam.qual[t] if sam.qual != '*' else '.'
                            aq = cov.setdefault(i, dict[int, list[str]]())
                            aq.setdefault(allele, list[str]()).append(qual)
                            counts[line_i] += 1
                    read += sz
                    ref += sz
                case 'I' or 'S':
                    read += sz
                case 'D' or 'N' or 'H' or 'P':
                    ref += sz
                case _:
                    pass
    if ignore_conflicts:
        for i in list(cov):
            if len(cov[i]) > 1:
                del cov[i]
    if len(cov) >= threshold:
        if is_tenx:
            BX = lines[0].aux('BX')
            XC = lines[0].aux('XC')
            if not XC:
                lines[0].aux('MI')
            if BX and not XC:
                raise ValueError("BX read lacks MI or XC tag")
            yield ((str(BX) if BX else ""), (XC.i if XC else -1)), [
                (sid, a, max(q))
                for sid, A in cov.items()
                for a, q in A.items()
            ]
        else:
            yield ("", -1), [
                (sid, a, max(q))
                for sid, A in cov.items()
                for a, q in A.items()
            ]


def parse_bam(
    vcf: VCF,
    sam_path: str,
    r_chr: str,
    threshold: int = 1,
    no_duplicates: bool = True,
    no_conflicts: bool = True,
    max_insert_size = -1,
    is_tenx: bool = False
) -> tuple[tuple[str, int], list[tuple[int, int, str]]]:
    """
    Reads a SAM/BAM. Does not have to be sorted.
    """

    # print list(vcf.chromosomes.keys())
    # sys.exit(0)

    seen = dict[str, SAMRecord]()
    with BAM(sam_path, r_chr) as sam:
        parse = parse_read(vcf, sam, ..., threshold, no_conflicts, is_tenx)
        for line_i, line in enumerate(sam):
            chr = sam.reference_name(line.tid)
            if chr != r_chr: break
            name = line.query_name
            if len(name) > 2 and name[-2] in '#/':
                name = name[:-2]
            if (
                (line.supplementary or line.secondary)
                or (no_duplicates and line.duplicate)
                or chr != sam.reference_name(line.mate_tid)
                or line.unmapped
                or not len(line.cigar)
                or chr not in vcf.chromosomes
            ):
                if not (line.supplementary or line.secondary) \
                   and not line.mate_unmapped and name in seen:
                    yield from parse([seen[name]])
                    del seen[name]
                continue
            elif name in seen:
                if max_insert_size > -1 and seen[name].insert_size > max_insert_size:
                    yield from parse([seen[name]])
                    yield from parse([line])
                else:
                    yield from parse([seen[name], line])
                del seen[name]
            else:
                seen[name] = line
        for line in seen.values():
            yield from parse([line])


def parse_phases(
    vcf: VCF,
    paths: list[tuple[str, int]],
    r_chr: str,
    skip_single: bool = True,
    is_tenx: bool = False
) -> Read:
    print 'Reading', r_chr, is_tenx
    reads = list[list[tuple[int, int, str]]]()
    for path, max_insert_size in paths:
        _, ext = splitext(path)
        coverages = dict[int, set[int]]()
        if is_tenx:
            d = dict[tuple[str, int], dict[int, dict[int, str]]]()
            for tag, alleles in parse_bam(vcf, path, r_chr, max_insert_size=max_insert_size, is_tenx=True):
                for pos, al, _ in alleles:
                    coverages.setdefault(pos, set[int]()).add(al)
                if tag[0] == "":
                    reads.append(alleles)
                else:
                    l = d.setdefault(tag, dict[int, dict[int, str]]())
                    for pos, al, q in alleles:
                        l.setdefault(pos, dict[int, str]())[al] = q
            for r in d.values():
                rx = list[tuple[int, int, str]]()
                for pos, all in r.items():
                    if len(all) == 1:
                        for a, q in all.items():
                            rx.append((pos, a, q))
                if rx: reads.append(rx)
        else:
            for _, alleles in parse_bam(vcf, path, r_chr, max_insert_size=max_insert_size):
                for pos, al, _ in alleles:
                    coverages.setdefault(pos, set[int]()).add(al)
                reads.append(alleles)
        # Ensure that all reads have expressed SNPs
        for read_i, read in enumerate(reads):
            read = [
                i for i in read
                if i[0] in coverages and (not ONLY_HETEROZYGOUS or len(coverages[i[0]]) >= 2)
            ]
            if len(read) and not (skip_single and len(read) <= 1):
                reads[read_i] = read 
            else:
                reads[read_i].clear()
    
    read_counter = dict[list[tuple[int, int]], int]()
    for r in reads:
        key = sorted((s, a) for s, a, _ in r)
        if len(key) <= int(skip_single):
            continue
        if key not in read_counter:
            read_counter[key] = 1
        else:
            read_counter[key] += 1
    for i, t in enumerate(read_counter.items()): 
        # print i, t
        yield Read({snp_id: snp_a for snp_id, snp_a in t[0]}, t[1], i)


def load_rna_data(
    vcf: VCF,
    r_chr: str,
    genes: list[Gene],
    paths: list[str],
    isoforms_path: str,
    args: list[float]
):
    reads = list(parse_phases(vcf, [(p, -1) for p in paths], r_chr, skip_single=False))
    if isoforms_path:
        print("Building IsoDict...")
        raise NotImplementedError("IsoDict")
        #isodict = build_isodict(isoforms_path)
        #genes = filter_transcripts(genes, isodict)

    # print('Building RNA graph...')
    rna = RNAGraph(vcf.snps, [g for g in genes if g.chr == r_chr], reads, args)
    return rna


def load_dna_data(
    vcf: VCF,
    r_chr: str,
    paths: list[tuple[str, int]],
    ploidy: int = 2,
    rna_reads: optional[list[Read]] = None,
    tenx: bool = False
) -> Graph:
    reads = list(parse_phases(vcf, paths, r_chr, skip_single=True, is_tenx=tenx))
    if rna_reads:
        reads += ~rna_reads
    for r in reads:
        r.special_snp = sorted(r.snps)[1]
        r.rates = [0.5] * ploidy

    return Graph(reads, ploidy)
